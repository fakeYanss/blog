<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="201902W9 Review, 一篇关于Spring RequestMapping的译文">
    

    <!--Author-->
    
        <meta name="author" content="fakeyanss">
    

    <!-- Title -->
    
    <title>Spring @RequestMapping详解 | Yet Another Possibility</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <!-- Content -->
    <section class="article-container">
<!-- Back Home -->
<a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

<!-- Page Header -->
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Spring @RequestMapping详解</h1>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>201902W9 Review, 一篇关于Spring RequestMapping的译文<br><a id="more"></a></p>
<hr>
<h1 id="Spring-RequestMapping"><a href="#Spring-RequestMapping" class="headerlink" title="Spring RequestMapping"></a>Spring RequestMapping</h1><p><a href="https://www.baeldung.com/spring-requestmapping" target="_blank" rel="noopener">原文</a><br>by <a href="https://www.baeldung.com/author/eugen/" target="_blank" rel="noopener">Eugen Paraschiv</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在这篇文章中，我们将关注于这个Spring MVC中常用的注释 - @RequestMapping。</p>
<p>简单地说，这个注释用于将网络请求映射到Spring Controller的方法。</p>
<h2 id="2-RequestMapping基础"><a href="#2-RequestMapping基础" class="headerlink" title="2. @RequestMapping基础"></a>2. <em>@RequestMapping</em>基础</h2><p>让我们从一个简单的例子开始 - 按照一些基本的标准将一个HTTP请求映射到一个方法。</p>
<h3 id="2-1-RequestMapping-按路径"><a href="#2-1-RequestMapping-按路径" class="headerlink" title="2.1. @RequestMapping - 按路径"></a>2.1. <em>@RequestMapping</em> - 按路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosBySimplePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get some Foos"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用简单的<em>curl</em>命令测试此映射，请运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-RequestMapping-HTTP方法"><a href="#2-2-RequestMapping-HTTP方法" class="headerlink" title="2.2. @RequestMapping - HTTP方法"></a>2.2. <em>@RequestMapping</em> - HTTP方法</h3><p>HTTP方法参数没有默认值 - 因此，如果我们不指定值，它将映射到任何HTTP请求。</p>
<p>这是一个简单的示例，类似于前一个示例 - 但这次映射到一个HTTP POST请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos"</span>, method = POST)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">postFoos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Post some Foos"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要通过<em>curl</em>命令测试POST ：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<h2 id="3-RequestMapping-和-HTTP-Headers"><a href="#3-RequestMapping-和-HTTP-Headers" class="headerlink" title="3. RequestMapping 和 HTTP Headers"></a>3. RequestMapping 和 HTTP Headers</h2><h3 id="3-1-带有headers-Attribute的-RequestMapping"><a href="#3-1-带有headers-Attribute的-RequestMapping" class="headerlink" title="3.1. 带有headers Attribute的@RequestMapping"></a>3.1. 带有headers Attribute的<em>@RequestMapping</em></h3><p>给请求指定一个header，可以进一步限制映射范围。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos"</span>, headers = <span class="string">"key=val"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosWithHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get some Foos with Header"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了测试运行，我们将使用<em>curl</em>的header参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H <span class="string">"key:val"</span> http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<p>更进一步，通过 <em>@RequestMapping</em>的 <em>header</em>属性实现多个header<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/foos"</span>, </span><br><span class="line">  headers = &#123; <span class="string">"key1=val1"</span>, <span class="string">"key2=val2"</span> &#125;, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosWithHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get some Foos with Header"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过命令测试这个方法<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -H <span class="string">"key1:val1"</span> -H <span class="string">"key2:val2"</span> http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<p>注意，对于<em>curl</em>语法，用冒号分离header的键和值，与HTTP中的规范相同，而在Spring中是用等号。</p>
<h3 id="3-2-RequestMapping-消费和生产"><a href="#3-2-RequestMapping-消费和生产" class="headerlink" title="3.2. @RequestMapping 消费和生产"></a>3.2. <em>@RequestMapping</em> 消费和生产</h3><p>映射<strong>由Controller产生的媒体类型</strong>的方法特别值得注意 - 我们可以通过上面介绍的 <em>@RequestMapping</em> 的headers属性，基于<em>Accept</em> header映射请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/foos"</span>, </span><br><span class="line">  method = GET, </span><br><span class="line">  headers = <span class="string">"Accept=application/json"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosAsJsonFromBrowser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get some Foos with Header Old"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配这种定义<em>Accept</em> header的方法是灵活的 - 是用包含而不是等于，所以一个下面这样的请求也能正确地匹配。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Accept:application/json,text/html"</span> http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<p>从Spring 3.1开始， <strong><em>@RequestMapping</em>注释具有produces和consumes属性</strong>，特别是为了这种：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/foos"</span>, </span><br><span class="line">  method = RequestMethod.GET, </span><br><span class="line">  produces = <span class="string">"application/json"</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosAsJsonFromREST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get some Foos with Header New"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外，带有<em>headers</em>属性的旧类型的映射将自动转换成Spring 3.1开始的新<em>produces</em>机制，所以结果是相同的。</p>
<p>同样的方式，通过<em>curl</em>进行consume：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Accept:application/json"</span> http://localhost:8080/spring-rest/ex/foos</span><br></pre></td></tr></table></figure></p>
<p>另外，<em>produces</em>也支持多值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/foos"</span>, </span><br><span class="line">  method = GET,</span><br><span class="line">  produces = &#123; <span class="string">"application/json"</span>, <span class="string">"application/xml"</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>记住这些 - 指定<em>accept</em> header的旧的方法和新的方法 - 基本上是相同的映射，所以Spring不允许它们一起使用 - 一起用将会导致：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Ambiguous mapping found. </span><br><span class="line">Cannot map <span class="string">'fooController'</span> bean method </span><br><span class="line">java.lang.String </span><br><span class="line">org.baeldung.spring.web.controller</span><br><span class="line">  .FooController.getFoosAsJsonFromREST()</span><br><span class="line">to </span><br><span class="line">&#123; [/ex/foos],</span><br><span class="line">  methods=[GET],params=[],headers=[],</span><br><span class="line">  consumes=[],produces=[application/json],custom=[]</span><br><span class="line">&#125;: </span><br><span class="line">There is already <span class="string">'fooController'</span> bean method</span><br><span class="line">java.lang.String </span><br><span class="line">org.baeldung.spring.web.controller</span><br><span class="line">  .FooController.getFoosAsJsonFromBrowser() </span><br><span class="line">mapped.</span><br></pre></td></tr></table></figure></p>
<p>关于新的<em>produces</em>和<em>consumes</em>机制的最后一点 - 与其他注释表现不同的是 - 当指定类型级别时，方法级别的注释不会补充而会覆盖类型级别的信息。</p>
<p>这句没理解，原文</p>
<blockquote>
<p>when specified at the type level, <strong>the method level annotations do not complement but override</strong> the type level information.</p>
</blockquote>
<p>当然，如果你想深入了解用Spring构建REST API - 请看<a href="https://www.baeldung.com/rest-with-spring-course?utm_source=blog&amp;utm_medium=web&amp;utm_content=art1&amp;utm_campaign=rws" target="_blank" rel="noopener">the new REST with Spring course</a>。</p>
<h2 id="4-RequestMapping使用路径变量"><a href="#4-RequestMapping使用路径变量" class="headerlink" title="4. RequestMapping使用路径变量"></a>4. <em>RequestMapping</em>使用路径变量</h2><p>映射URI的一部分可以通过 <em>@PathVariable</em>注解绑定到变量。</p>
<h3 id="4-1-单个-PathVariable"><a href="#4-1-单个-PathVariable" class="headerlink" title="4.1 单个 @PathVariable"></a>4.1 单个 <em>@PathVariable</em></h3><p>一个简单的单路径变量例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos/&#123;id&#125;"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosBySimplePathWithPathVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @PathVariable(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Foo with id="</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以用<em>curl</em>测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/spring-rest/ex/foos/1</span><br></pre></td></tr></table></figure></p>
<p>如果方法的参数名和路径名相同，可以只用 <em>@PathVariable</em> 而不附加值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos/&#123;id&#125;"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosBySimplePathWithPathVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @PathVariable String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Foo with id="</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意 <em>@PathVariable</em> 受利于自动类型转换，所以我们也可以修饰id为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PathVariable</span> <span class="keyword">long</span> id</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-多个-PathVariable"><a href="#4-2-多个-PathVariable" class="headerlink" title="4.2 多个 @PathVariable"></a>4.2 多个 <em>@PathVariable</em></h3><p>更复杂的URI可能需要映射URI的多个部分到多个值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/foos/&#123;fooid&#125;/bar/&#123;barid&#125;"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String getFoosBySimplePathWithPathVariables</span><br><span class="line">  (<span class="meta">@PathVariable</span> <span class="keyword">long</span> fooid, <span class="meta">@PathVariable</span> <span class="keyword">long</span> barid) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Bar with id="</span> + barid + </span><br><span class="line">      <span class="string">" from a Foo with id="</span> + fooid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样这可以用<em>curl</em>容易的测试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/spring-rest/ex/foos/1/bar/2</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-带正则表达式的-PathVariable"><a href="#4-3-带正则表达式的-PathVariable" class="headerlink" title="4.3 带正则表达式的 @PathVariable"></a>4.3 带正则表达式的 <em>@PathVariable</em></h3><p>正则表达式也能用来映射 <em>@PathVariable</em>；举个例子，我们可以限制映射id只接受数字类型的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/bars/&#123;numericId:[\\d]+&#125;"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBarsBySimplePathWithPathVariable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @PathVariable <span class="keyword">long</span> numericId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Bar with id="</span> + numericId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这将意味着下面的URI可以适配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/spring-rest/ex/bars/1</span><br></pre></td></tr></table></figure></p>
<p>但这个不能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/spring-rest/ex/bars/abc</span><br></pre></td></tr></table></figure></p>
<h2 id="5-RequestMapping使用Request-Parameters"><a href="#5-RequestMapping使用Request-Parameters" class="headerlink" title="5. RequestMapping使用Request Parameters"></a>5. <em>RequestMapping</em>使用Request Parameters</h2><p>@RequestMapping允许方便的使用 <em>@RequestParam</em>注解映射URL参数。</p>
<p>我们现在映射一个这样的URI请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/spring-rest/ex/bars?id=100</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/bars"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBarBySimplePathWithRequestParam</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @RequestParam(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Bar with id="</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着在controller方法中使用 <em>@RequestParam(“id”)</em> 注解取出<em>id</em>参数的值。</p>
<p>要发送带<em>id</em>参数的请求，我们在<em>curl</em>中使用参数支持：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -d id=100 http://localhost:8080/spring-rest/ex/bars</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，参数直接绑定而不先声明。</p>
<p>对于更进一步的场景， <em>@RequestMapping</em>有可选的参数定义 - 作为又一个限制请求映射的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/ex/bars"</span>, params = <span class="string">"id"</span>, method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBarBySimplePathWithExplicitRequestParam</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @RequestParam(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Get a specific Bar with id="</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至可以更灵活的映射 - 可以设置多个<em>params</em>值，并且不是所有都使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/bars"</span>, </span><br><span class="line">  params = &#123; <span class="string">"id"</span>, <span class="string">"second"</span> &#125;, </span><br><span class="line">  method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBarBySimplePathWithExplicitRequestParams</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  @RequestParam(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Narrow Get a specific Bar with id="</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，一个像这样的请求URI：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/spring-rest/ex/bars?id=100&amp;second=something</span><br></pre></td></tr></table></figure></p>
<p>将总会被映射到最好的适配 - 更进一步的适配，同时定义<em>id</em>和<em>second</em>参数。</p>
<h2 id="6-RequestMapping-Corner-Cases"><a href="#6-RequestMapping-Corner-Cases" class="headerlink" title="6. RequestMapping Corner Cases"></a>6. <em>RequestMapping</em> Corner Cases</h2><h3 id="6-1-RequestMapping-–-多个路径映射到同一Controller方法"><a href="#6-1-RequestMapping-–-多个路径映射到同一Controller方法" class="headerlink" title="6.1. @RequestMapping – 多个路径映射到同一Controller方法"></a>6.1. <em>@RequestMapping</em> – 多个路径映射到同一Controller方法</h3><p>虽然一个单个 <em>@RequestMapping</em>路径值通常用于单个controller方法， 但这只是一种好的用法，而不是强制规则 - 有一些情况下，多个请求到同一方法的可能是必要的。在那种情况下， <strong>@RequestMapping的value属性接收多个映射</strong>，而不是一个映射：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = &#123; <span class="string">"/ex/advanced/bars"</span>, <span class="string">"/ex/advanced/foos"</span> &#125;, </span><br><span class="line">  method = GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFoosOrBarsByPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Advanced - Get some Foos or Bars"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，这两个<em>curl</em>命令应该使用相同的方法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://localhost:8080/spring-rest/ex/advanced/foos</span><br><span class="line">curl -i http://localhost:8080/spring-rest/ex/advanced/bars</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-RequestMapping-–-多个HTTP请求方法到同一个controller方法"><a href="#6-2-RequestMapping-–-多个HTTP请求方法到同一个controller方法" class="headerlink" title="6.2. @RequestMapping – 多个HTTP请求方法到同一个controller方法"></a>6.2. <em>@RequestMapping</em> – 多个HTTP请求方法到同一个controller方法</h3><p>用不同HTTP请求方式的多个请求可以被映射到同一个Controller方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"/ex/foos/multiple"</span>, </span><br><span class="line">  method = &#123; RequestMethod.PUT, RequestMethod.POST &#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">putAndPostFoos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Advanced - PUT and POST within single method"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用<em>curl</em>，这些请求都被打到同一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http:<span class="comment">//localhost:8080/spring-rest/ex/foos/multiple</span></span><br><span class="line">curl -i -X PUT http:<span class="comment">//localhost:8080/spring-rest/ex/foos/multiple</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-RequestMapping-对所有请求的返回"><a href="#6-3-RequestMapping-对所有请求的返回" class="headerlink" title="6.3. @RequestMapping - 对所有请求的返回"></a>6.3. <em>@RequestMapping</em> - 对所有请求的返回</h3><p>对所有请求实现一个返回，可以使用一个特别的HTTP方法 - 例如，对GET方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"*"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Fallback for GET Requests"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者对所有请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(</span><br><span class="line">  value = <span class="string">"*"</span>, </span><br><span class="line">  method = &#123; RequestMethod.GET, RequestMethod.POST ... &#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">allFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Fallback for All Requests"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-4-模糊映射错误"><a href="#6-4-模糊映射错误" class="headerlink" title="6.4 模糊映射错误"></a>6.4 模糊映射错误</h3><p>模糊映射错误发生与：当Spring评估两个或多个请求映射对于不同的Controller方法是相同的。当两个请求映射有同样的HTTP方法、URL、参数、头部和媒体类型时，它们就是相同的。例如，这是一个模糊映射：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"foos/duplicate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Duplicate"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"foos/duplicate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">duplicateEx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Duplicate"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抛出的异常通常在这些行有异常信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Ambiguous mapping.</span><br><span class="line">  Cannot map <span class="string">'fooMappingExamplesController'</span> method </span><br><span class="line">  <span class="keyword">public</span> java.lang.String org.baeldung.web.controller.FooMappingExamplesController.duplicateEx()</span><br><span class="line">  to &#123;[/ex/foos/duplicate],methods=[GET]&#125;:</span><br><span class="line">  There is already <span class="string">'fooMappingExamplesController'</span> bean method</span><br><span class="line">  <span class="keyword">public</span> java.lang.String org.baeldung.web.controller.FooMappingExamplesController.duplicate() mapped.</span><br></pre></td></tr></table></figure></p>
<p>仔细阅读错误信息，指出Spring不能映射方法<em>org.baeldung.web.controller.FooMappingExamplesController.duplicateEx()</em> ，因为它与一个已经映射的<em>org.baeldung.web.controller.FooMappingExamplesController.duplicate()</em> 有冲突。</p>
<p>下面这个代码段将不会产生模糊映射错误，因为两个方法返回不同的内容类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"foos/duplicate"</span>, produces = MediaType.APPLICATION_XML_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Duplicate"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"foos/duplicate"</span>, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">duplicateEx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Duplicate"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-新的请求映射捷径"><a href="#7-新的请求映射捷径" class="headerlink" title="7. 新的请求映射捷径"></a>7. 新的请求映射捷径</h2><p>Spring Framework 4.3引入了<a href="https://www.baeldung.com/spring-new-requestmapping-shortcuts" target="_blank" rel="noopener">一些新的</a>HTTP映射注释，所有这些都基于 <em>@RequestMapping</em> ：</p>
<ul>
<li><strong>@GetMapping</strong></li>
<li><strong>@PostMapping</strong></li>
<li><strong>@PutMapping</strong></li>
<li><strong>@DeleteMapping</strong></li>
<li><strong>@PatchMapping</strong></li>
</ul>
<p>这些新的注解可以提高可读性，减少代码冗长。让我们看看这些新的注解在创建一个支持CRUD操作RESTFUL API的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; getBazz(<span class="meta">@PathVariable</span> String id)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> Bazz(id, <span class="string">"Bazz"</span>+id), HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; newBazz(<span class="meta">@RequestParam</span>(<span class="string">"name"</span>) String name)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> Bazz(<span class="string">"5"</span>, name), HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; updateBazz(</span><br><span class="line">  <span class="meta">@PathVariable</span> String id,</span><br><span class="line">  <span class="meta">@RequestParam</span>(<span class="string">"name"</span>) String name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> Bazz(id, name), HttpStatus.OK);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; deleteBazz(<span class="meta">@PathVariable</span> String id)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> Bazz(id), HttpStatus.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>深入了解这些可以在<a href="https://www.baeldung.com/spring-new-requestmapping-shortcuts" target="_blank" rel="noopener">这里</a>找到。</p>
<h2 id="8-Spring配置"><a href="#8-Spring配置" class="headerlink" title="8. Spring配置"></a>8. Spring配置</h2><p>Spring MVC的配置足够简单 - 考虑到我们的<em>FooController</em>被定义在接下来的包里:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.baeldung.spring.web.controller;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们只用一个 <em>@Configuration</em> 去启用完整的MVC支持并为控制器配置类路径扫描：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(&#123; <span class="string">"org.baeldung.spring.web.controller"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a>9. 结论</h2><p>这篇文章专注于<strong>Spring的 <em>@RequestMapping</em> 注解</strong> - 讨论一个简单的用例, HTTP头的映射, <em>@PathVariable</em> 绑定URI部分, 使用URL参数工作, 和使用 <em>@RequestParam</em> 注解.</p>
<p>如果你想学习如何使用另一个Spring MVC的核心注解, 你可以<a href="https://www.baeldung.com/spring-mvc-and-the-modelattribute-annotation" target="_blank" rel="noopener">在这浏览 <em>@ModelAttribu</em> 注解</a>.</p>
<p>这篇文章的全部代码在<a href="https://github.com/eugenp/tutorials/tree/master/spring-rest-simple" target="_blank" rel="noopener">Github</a>可见. 这是一个Maven项目, 所以它可以很容易被导入和运行.</p>
<p><br></p>
<hr>
<p id="div-border-left-red"><i>DigitalOcean 优惠码，注册充值 $5 送 $100，<a href="https://m.do.co/c/282d5e1cf06e" target="_blank" rel="noopener">链接一</a> <a href="https://m.do.co/c/5eefb87c26cd" target="_blank" rel="noopener">链接二</a></i></p><br><p id="div-border-left-red"><i>Lastly, welcome to follow me on <a href="https://github.com/fakeYanss" target="_blank" rel="noopener">github</a></i></p>
 
                <!-- Meta -->
                <div class="post-meta">
                    <hr>
                    <br>
                    <div class="post-tags">
                        
                            

<a href="/tags/Review/">#Review</a> <a href="/tags/Spring/">#Spring</a> <a href="/tags/RequestMapping/">#RequestMapping</a>


                        
                    </div>
                    <div class="post-date">
                        
                            2019 年 03 月 01 日
                        
                    </div>
                </div>
            </div>

            <!-- Comments -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- Disqus Comments -->

<div id="disqus_thread" class="comment"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = 'you-yue-ru-tie';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


            </div>
        </div>
    </div>
</article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    
    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© zchen9 🙋 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-112380656-1', 'auto');
        ga('send', 'pageview');

    </script>


    <!-- Service Worker -->
    <!-- if using service worker -->

    
</body>

</html>