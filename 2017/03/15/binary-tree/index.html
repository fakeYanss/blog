<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="这里理一下数据结构中树和二叉树的知识。">
    

    <!--Author-->
    
        <meta name="author" content="fakeyanss">
    

    <!-- Title -->
    
    <title>树和二叉树 | Yet Another Possibility</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/blog/css/style.css">

    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Noto+Serif:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- jQuery -->
    <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
    <!-- Bootstrap -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <!-- Content -->
    <section class="article-container">
    <!-- Back Home -->
    <a class="nav-back" href="/blog/">
    <i class="fa fa-puzzle-piece"></i>
</a>

        <!-- Page Header -->
        <header class="intro-header">
            <div class="container">
                <div class="row">
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <div class="post-heading">
                            <h1>
                                树和二叉树
                            </h1>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Post Content -->
        <article>
            <div class="container">
                <div class="row">
                    <!-- Post Main Content -->
                    <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <p>这里理一下数据结构中树和二叉树的知识。</p>
<a id="more"></a>
<hr>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><blockquote>
<p>（递归）一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由称作<strong>根</strong>的节点 r 以及 0 个或多个非空的（子）树 <strong>$T_1，T_2，···，T_k$</strong> 组成，这些子树中每一棵的根都被来自根 r 的一条有向<strong>边</strong>所连结。</p>
</blockquote>
<h2 id="树的实现"><a href="#树的实现" class="headerlink" title="树的实现"></a>树的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树节点的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Object element;</span><br><span class="line">    TreeNode firstChild;</span><br><span class="line">    TreeNode netSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将每个节点的所有儿子都放到树节点的链表中。</p>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><ul>
<li>先序遍历</li>
<li>后序遍历</li>
<li>中序遍历</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote>
<p>二叉树（binary tree）是一棵树，其中每个节点都不能有多于两个的儿子。</p>
</blockquote>
<p>二叉树平均深度为 $O(\sqrt{N})$，最大深度为 $N$。<br>二叉查找树的平均深度为 $O(log N)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Friendly data;accessible by other package toutines</span></span><br><span class="line">    Object element;<span class="comment">//The data in the node</span></span><br><span class="line">    BinaryNode left;<span class="comment">//Left child</span></span><br><span class="line">    BinaryNode right;<span class="comment">//right child</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找树ADT——二叉查找树"><a href="#查找树ADT——二叉查找树" class="headerlink" title="查找树ADT——二叉查找树"></a>查找树ADT——二叉查找树</h2><blockquote>
<p>使二叉树成为查找树的性质是，对于树中的每个节点 X ，它的左子树中所有项的值小于 X 中的项，而它的右子树中所有项的值大于 X 中的项。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinaryNode类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span>&lt;<span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//Constructors</span></span><br><span class="line">    BinaryNode(AnyType theElement)</span><br><span class="line">    &#123;<span class="keyword">this</span>(theElement, <span class="keyword">null</span>, <span class="keyword">null</span>);&#125;</span><br><span class="line"></span><br><span class="line">	BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt, BinaryNode&lt;AnyType&gt; rt)</span><br><span class="line">	&#123;element = theElement; left = lt; right = rt;&#125;</span><br><span class="line"></span><br><span class="line">	AnyType element;<span class="comment">//The data in the node</span></span><br><span class="line">	BinaryNode&lt;AnyType&gt; left;<span class="comment">//Left child</span></span><br><span class="line">	BinaryNode&lt;AnyType&gt; right;<span class="comment">//Right child</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树架构"><a href="#二叉查找树架构" class="headerlink" title="二叉查找树架构"></a>二叉查找树架构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树架构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">AnyType</span> <span class="keyword">extends</span> <span class="title">comparable</span>&lt;? <span class="title">super</span> <span class="title">AnyType</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryNode</span>&lt;<span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="comment">//Constructors</span></span><br><span class="line">	    BinaryNode(AnyType theElement)</span><br><span class="line">	    &#123;<span class="keyword">this</span>(theElement, <span class="keyword">null</span>, <span class="keyword">null</span>);&#125;</span><br><span class="line"></span><br><span class="line">		BinaryNode(AnyType theElement, BinaryNode&lt;AnyType&gt; lt, BinaryNode&lt;AnyType&gt; rt)</span><br><span class="line">		&#123;element = theElement; left = lt; right = rt;&#125;</span><br><span class="line"></span><br><span class="line">		AnyType element;<span class="comment">//The data in the node</span></span><br><span class="line">		BinaryNode&lt;AnyType&gt; left;<span class="comment">//Left child</span></span><br><span class="line">		BinaryNode&lt;AnyType&gt; right;<span class="comment">//Right child</span></span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span> BinaryNode&lt;AnyType&gt; root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; root = <span class="keyword">null</span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; root = <span class="keyword">null</span>; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> root == <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">( AnyType x )</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> contains( x, root ); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AnyType <span class="title">findMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> UnderflowException();</span><br><span class="line">		<span class="keyword">return</span> findMin(root).element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AnyType <span class="title">finMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> UnderflowException();</span><br><span class="line">		<span class="keyword">return</span> finMax(roow).element;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(AnyType x)</span></span></span><br><span class="line"><span class="function">	</span>&#123; root = insert(x,root); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AnyType x)</span></span></span><br><span class="line"><span class="function">	</span>&#123; root = remove(x,root); &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty())</span><br><span class="line">			System.out.println(<span class="string">"Empty tree"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			printTree(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> contains(x, t.left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> contains(x, t.right);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//Match</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">findMin</span><span class="params">(BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> t;</span><br><span class="line">		<span class="keyword">return</span> findMin(t.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">finMax</span><span class="params">(BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t != <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">while</span>(t.right != <span class="keyword">null</span>)</span><br><span class="line">				t = t.right;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">insert</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> BinaryNode&lt;&gt;(x, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">			t.left = insert(x, t.left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">			t.right = insert(x, t.right);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			;<span class="comment">//Duplicate; do nothing</span></span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">remove</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> t;<span class="comment">//Item not found; do nothing</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">			t.left = remove(x, t.left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">			t.right = remove(x, t.right);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="keyword">null</span> &amp;&amp; t.right != <span class="keyword">null</span>)<span class="comment">//Two children</span></span><br><span class="line">		&#123;</span><br><span class="line">			t.element = findMin(t.right).element;</span><br><span class="line">			t.right = remove(t.element, t.right);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = (t.left != <span class="keyword">null</span>) ? t.left : t.right;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">			printTree(t.left);</span><br><span class="line">			System.out.println(t.element);</span><br><span class="line">			printTree(t.right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h3><blockquote>
<p>如果树 $T$ 中含有项 $X$ 的节点，那么这个操作需要返回true，如果这样的节点不存在则返回false。树的结构使这种操作很简单。如果 $T$ 是空集，那么久返回false。否则，如果存储在 $T$ 处的项是 $X$ ，那么可以返回true。否则，我们对数 $T$ 的左子树或右子树进行一次递归调用，则依赖于 $X$ 与存储在 $T$ 中的项的关系。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal method to find an item in a subtree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x is item to search for.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the node that roots the subtree.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the item is found; false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树的contains操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="keyword">null</span>) </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> contains(x, t.left);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> contains(x, t.right);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//Match</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归用while循环代替</span></span><br><span class="line">   <span class="keyword">while</span>(compareResult &lt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    t=t.left;</span><br><span class="line">    compareResult = x.compareTo(t.element);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>算法表达式的简明性是以速度的降低为代价的。</strong></p>
</blockquote>
<h3 id="findMin方法和findMax方法"><a href="#findMin方法和findMax方法" class="headerlink" title="findMin方法和findMax方法"></a>findMin方法和findMax方法</h3><blockquote>
<p>这两个方法分别返回树中包含最小元和最大元的节点的引用。为执行findMin，从根开始并且只要有左儿子就向左进行。 终止点就是最小的元素。findMax除分支朝向右儿子其余过程相同。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用递归编写findMin，用非递归编写findMax</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Internal method to find the smallest item in a subtree</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  t the node that roots the subtree.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> node containing the smallest item</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">findMin</span><span class="params">(BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t.left == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	<span class="keyword">return</span> findMin(t.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Internal method to find the largest item in a subtree</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  t the node that roots the subtree.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> node containing the largest item.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">finMax</span><span class="params">(BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">while</span>(t.right != <span class="keyword">null</span>)</span><br><span class="line">			t = t.right;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法"></a>insert方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal method to insert into a subtree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x the item to insert</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the node that roots the subtree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new root of the subtree</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">insert</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BinaryNode&lt;&gt;(x, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">		t.left = insert(x, t.left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">		t.right = insert(x, t.right);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		;<span class="comment">//Duplicate; do nothing</span></span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal method to remove from a subtree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x the item to remove.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the node that roots the subtree.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new root of the subtree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">remove</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> t;<span class="comment">//Item not found; do nothing</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">		t.left = remove(x, t.left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">		t.right = remove(x, t.right);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t.left != <span class="keyword">null</span> &amp;&amp; t.right != <span class="keyword">null</span>)<span class="comment">//Node that has two children</span></span><br><span class="line">	&#123;</span><br><span class="line">		t.element = findMin(t.right).element;<span class="comment">//Find the minimum item of right subtree</span></span><br><span class="line">		t.right = remove(t.element, t.right);<span class="comment">//Remove the node of minimum item recursively			</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		t = (t.left != <span class="keyword">null</span>) ? t.left : t.right;<span class="comment">//Node that has one children; parent of the node roots subtree of the node</span></span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果节点是树叶，可以直接删除。</li>
<li>如果节点有一个儿子，这该节点需要在其父节点调整自己的链以绕过该节点</li>
<li>如果节点有两个儿子，一般的删除策略是用其右子树的最小的数据代替该节点，并在右子树中递归地删除那个最小的节点</li>
</ul>
</blockquote>
<p>另外，如果删除的次数不多，通常使用的策略是懒惰删除（lazy deletion）：当一个元素要被删除时，它仍留在树中，而只是被标记为删除。</p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><blockquote>
<p>AVL树是<strong>带有平衡条件</strong>的二叉查找树。<br>这个平衡条件必须要容易保持，而且它保证树的深度须是 $O(log N)$ 。<br>一个AVL树是其每个节点的左子树和右子树的高度最多差 1 的二叉查找树（空树的高度定义为 -1）。</p>
</blockquote>
<p>可以知道，在高度为 $h$ 的AVL树中，最少节点数 $S(h)=S(h-1)+S(h-2)+1$ 给出。<br>对于 $h=0, S(h)=1; h=1, S(h)=2$ 。<br>函数 $S(h)$ 与斐波那契数密切相关。</p>
<p>那么重点来了，对于AVL树的插入操作，有可能破坏树的平衡性。这时候，我们就需要在这一步插入完成之前恢复平衡的性质。</p>
<p>可以知道，从插入的节点往上，逆行到根，若发生平衡信息改变，那么改变的节点一定在这条路径上。我们需要找出这个需要重新平衡的节点 $\alpha$ 。</p>
<p>对于节点 $\alpha$ ，不平衡条件可能出现在一下四种操作中：</p>
<ol>
<li>对 $\alpha$ 的左儿子的左子树进行一次插入（LL）。</li>
<li>对 $\alpha$ 的左儿子的右子树进行一次插入（LR）。</li>
<li>对 $\alpha$ 的右儿子的左子树进行一次插入（RL）。</li>
<li>对 $\alpha$ 的右儿子的右子树进行一次插入（RR）。</li>
</ol>
<p>对于1和4，是插入发生在外边的情况，通过对树的一次<strong>单旋转</strong>而完成调整。对于2和3，是插入发生在内部的情况，通过对树的一次<strong>双旋转</strong>而完成调整。</p>
<p>这里先对AvlNode类进行定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvlNode</span>&lt;<span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//Constructors</span></span><br><span class="line">	AvlNode(AnyType theElement)</span><br><span class="line">	&#123;<span class="keyword">this</span>(theElement, <span class="keyword">null</span>, <span class="keyword">null</span>);&#125;</span><br><span class="line"></span><br><span class="line">	AvlNode(AnyType theElement, AvlNode&lt;AnyType&gt; lt, AvlNode&lt;AnyType&gt; rt)</span><br><span class="line">	&#123;element = theElement; left = lt; right = rt; height = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">	AnyType element;<span class="comment">//The data in the code</span></span><br><span class="line">	AvlNode&lt;AnyType&gt; left;<span class="comment">//Left child</span></span><br><span class="line">	AvlNode&lt;AnyType&gt; right;<span class="comment">//Right child</span></span><br><span class="line">	<span class="keyword">int</span> height;<span class="comment">//Height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要一个返回节点高度的方法：</p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回AVL树的节点高度</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * return the height of node t, or -1, if null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(AvlNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t == <span class="keyword">null</span> ? -<span class="number">1</span> : t.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h3><p><img src="https://foreti.me/imgplace/2019/20190429221300.png" alt="LL单旋转"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rotate binary tree node with left child.</span></span><br><span class="line"><span class="comment"> * For AVL trees, this is a single rotation for case 1.</span></span><br><span class="line"><span class="comment"> * Update heights, then return new root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">RotationWithLeftChild</span><span class="params">(AvlNode&lt;AnyType&gt; k2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    AVLTreeNode&lt;AnyType&gt; k1 = k2.left;  </span><br><span class="line">  </span><br><span class="line">    k2.left = k1.right;  </span><br><span class="line">    k1.right = k2;  </span><br><span class="line">  </span><br><span class="line">    k2.height = Math.max( height(k2.left), height(k2.right)) + <span class="number">1</span>;  </span><br><span class="line">    k1.height = Math.max( height(k1.left), k2.height) + <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> k1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://foreti.me/imgplace/2019/20190429221627.png" alt="RR单旋转"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rotate binary tree node with right child.</span></span><br><span class="line"><span class="comment"> * For AVL trees, this is a single rotation for case 4.</span></span><br><span class="line"><span class="comment"> * Update heights, then return new root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">RotationWithRightChild</span><span class="params">(AvlNode&lt;AnyType&gt; k1)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    AVLTreeNode&lt;AnyType&gt; k2 = k1.right;  </span><br><span class="line">  </span><br><span class="line">  	k1.right = k2.left;  </span><br><span class="line">   	k2.left = k1;  </span><br><span class="line">   	</span><br><span class="line">   	k1.height = Math.max( height(k1.left), height(k1.right)) + <span class="number">1</span>;  </span><br><span class="line">    k1.height = Math.max( height(k2.right), k1.height) + <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> k2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h3><p><img src="https://foreti.me/imgplace/2019/20190429221709.png" alt="LR双旋转"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double rotate binary tree node: first left child</span></span><br><span class="line"><span class="comment"> * with its right child; then node k3 with new left child.</span></span><br><span class="line"><span class="comment"> * For AVL trees, this is a double rotation for case 2.</span></span><br><span class="line"><span class="comment"> * Update heights, then return new root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">doubleWithLeftChild</span><span class="params">(AvlNode&lt;AnyType&gt; k3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	k3.left = RotationWithRightChild(k3.left);</span><br><span class="line">	<span class="keyword">return</span> RotationWithLeftChild(k3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://foreti.me/imgplace/2019/20190429221732.png" alt="RL双旋转"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double rotate binary tree node: first right child</span></span><br><span class="line"><span class="comment"> * with its left child; then node k1 with new right child.</span></span><br><span class="line"><span class="comment"> * For AVL trees, this is a double rotation for case 3.</span></span><br><span class="line"><span class="comment"> * Update heights, then return new root.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">doubleWithRightChild</span><span class="params">(AvlNode&lt;AnyType&gt; k1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	k1.right = RotationWithRightChild(k1.right);</span><br><span class="line">	<span class="keyword">return</span> RotationWithLeftChild(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AVL树的插入方法"><a href="#AVL树的插入方法" class="headerlink" title="AVL树的插入方法"></a>AVL树的插入方法</h3><blockquote>
<p>插入方法就是前文中的insert方法，只是在最后一行调用平衡的方法以保持AVL树的平衡性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal method to insert into a subtree.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  x the item to insert.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the node that roots the subtree.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new root of the subtree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">insert</span><span class="params">(AnyType x, AvlNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span>	AvlNode&lt;&gt;(x, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(compareResult &lt; <span class="number">0</span>)</span><br><span class="line">		t.left = insert(x, t.left);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(compareResult &gt; <span class="number">0</span>)</span><br><span class="line">		t.right = insert(x, t.right);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		;<span class="comment">//Duplicate; do nothing</span></span><br><span class="line">	<span class="keyword">return</span> balance(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALLOWED_IMBALLANCE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Assume t is either balanced of within one of being balanced</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode&lt;AnyType&gt; <span class="title">balance</span><span class="params">(AvlNode&lt;AnyType&gt; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(height(t.left) - height(t.right) &gt; ALLOWED_IMBALLANCE)</span><br><span class="line">		<span class="keyword">if</span>(height(t.left.left) &gt;= height(t.left.right))</span><br><span class="line">			t = RotationWithLeftChild(t);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = doubleWithLeftChild(t);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	<span class="keyword">if</span>(height(t.right) - height(t.left) &gt; ALLOWED_IMBALLANCE)</span><br><span class="line">		<span class="keyword">if</span>(height(t.right.right) &gt;= height(t.right.left))</span><br><span class="line">			t = RotationWithRightChild(t);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = doubleWithRightChild(t);</span><br><span class="line"></span><br><span class="line">	t.height = Math.max(height(t.left), height(t.right)) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="AVL树的删除方法"><a href="#AVL树的删除方法" class="headerlink" title="AVL树的删除方法"></a>AVL树的删除方法</h3><blockquote>
<p>和AVL树的插入一样，只用在前文的删除方法最后加上一行调用平衡的方法即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private AvlNode&lt;AnyType&gt; remove(AnyType x, AvlNode&lt;AnyType&gt; t)</span><br><span class="line">&#123;</span><br><span class="line">	if(t == null)</span><br><span class="line">		return t;//Item not found; do nothing</span><br><span class="line"></span><br><span class="line">	int compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">	if(compareResult &lt; 0)</span><br><span class="line">		t.left = remove(x, t.left);</span><br><span class="line">	else if(compareResult &gt; 0)</span><br><span class="line">		t.right = remove(x, t.right);</span><br><span class="line">	else if(t.left != null &amp;&amp; t.right != null)//Node that has two children</span><br><span class="line">	&#123;</span><br><span class="line">		t.element = findMin(t.right).element;//Find the minimum item of right subtree</span><br><span class="line">		t.right = remove(t.element, t.right);//Remove the node of minimum item recursively			</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		t = (t.left != null) ? t.left : t.right;//Node that has one children; parent of the node roots subtree of the node</span><br><span class="line">	return balance(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


                            <!-- Meta -->
                            <div class="post-meta">
                                <hr>
                                <br>
                                <div class="post-tags">
                                    
                                        

<a href="/blog/tags/binary-tree/">#binary tree</a>


                                            
                                </div>
                                <div class="post-date">
                                    
                                        2017 年 03 月 15 日
                                    
                                </div>
                            </div>
                    </div>

                    <!-- Comments -->
                    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                        <!-- Disqus Comments -->

<div id="disqus_thread" class="comment"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = 'you-yue-ru-tie';

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


                    </div>
                </div>
            </div>
        </article>
</section>

<!-- Image viewer-->

    <!-- Custom picture view-->
    <link href="/blog/css/viewer.min.css" rel="stylesheet" />
    <script
      src="/blog/js/viewer.min.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
    
    <script type="text/javascript">
      // set image viewer
      Viewer.setDefaults({
        zoomRatio: [0.5],
        navbar: false,
        toolbar: false,
        button: false,
        title: [2, (image, imageData) => `${image.alt}`],
        show: function() {
          this.viewer.zoomTo(0.5);
        }
      });
      var imageList = document.getElementsByTagName("img");
      Array.prototype.forEach.call(imageList, element => {
        var viewer = new Viewer(element);
      });
    </script>

    

<!-- TOC -->

    <aside id="article-toc" role="navigation" class="fixed">
        <div id="article-toc-inner">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#树的定义"><span class="toc-number">1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的实现"><span class="toc-number">2.</span> <span class="toc-text">树的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的遍历"><span class="toc-number">3.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-number">4.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找树ADT——二叉查找树"><span class="toc-number">5.</span> <span class="toc-text">查找树ADT——二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉查找树架构"><span class="toc-number">5.1.</span> <span class="toc-text">二叉查找树架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#contains方法"><span class="toc-number">5.2.</span> <span class="toc-text">contains方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findMin方法和findMax方法"><span class="toc-number">5.3.</span> <span class="toc-text">findMin方法和findMax方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#insert方法"><span class="toc-number">5.4.</span> <span class="toc-text">insert方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove方法"><span class="toc-number">5.5.</span> <span class="toc-text">remove方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL树"><span class="toc-number">6.</span> <span class="toc-text">AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单旋转"><span class="toc-number">6.1.</span> <span class="toc-text">单旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双旋转"><span class="toc-number">6.2.</span> <span class="toc-text">双旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树的插入方法"><span class="toc-number">6.3.</span> <span class="toc-text">AVL树的插入方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL树的删除方法"><span class="toc-number">6.4.</span> <span class="toc-text">AVL树的删除方法</span></a></li></ol></li></ol>
        </div>
    </aside>

    <!-- Scripts -->
    <script type="text/javascript">
    console.log("© zchen9 🙋 2015-" + new Date().getFullYear());
</script>
  
    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-112380656-1', 'auto');
        ga('send', 'pageview');

    </script>


    <!-- Service Worker -->
    <!-- if using service worker -->

    <script text="module">
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/blog/js/sw.js")
          .then(function() {
            console.log("A new service worker is being installed.");
          })
          .catch(function(error) {
            console.log("Service worker registration failed:", error);
          });
      } else {
        console.log("Service workers are not supported.");
      }
    </script>

    
</body>

</html>